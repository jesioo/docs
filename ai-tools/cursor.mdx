---
title: "Cursor & dx Integration"  
description: "Seamless integration between Cursor AI editor and dx terminal workflows"
icon: "cursor"
---

Cursor's AI capabilities combine perfectly with dx's structured terminal workflows, creating an intelligent development environment that understands both your code and your processes.

## Why Cursor + dx?

<CardGroup cols={2}>
  <Card title="Contextual AI" icon="brain">
    Cursor understands your dx workflows and suggests appropriate commands
  </Card>
  <Card title="Terminal Integration" icon="terminal">
    AI can suggest and execute dx commands directly in Cursor's terminal
  </Card>
  <Card title="Workflow Learning" icon="chart-line">
    Cursor learns from your dx aliases and menu patterns
  </Card>
  <Card title="Code-to-Command" icon="link">
    AI connects code changes to appropriate dx commands automatically
  </Card>
</CardGroup>

## Setup for dx Projects

### 1. Create Cursor Rules for dx

In your project root:

```bash
mkdir -p .cursor
```

Create `.cursor/dx-rules.md`:

````markdown
# dx Development Assistant Rules

You are an AI development assistant working with a dx-powered development environment. Always consider dx workflows and suggest appropriate dx commands for development tasks.

## dx Integration Principles

### Command Suggestion Strategy
- When user mentions building: suggest `dx build`
- When user mentions testing: suggest `dx test` 
- When user mentions deployment: suggest `dx deploy`
- Always check available aliases first: `dx aliases`
- For complex workflows: suggest recording with `--record`

### Context Awareness
- Understand project type from dx menu configuration
- Recognize workflow patterns from dx.yaml/menu.toml
- Suggest relevant aliases based on current task
- Consider both TUI and CLI usage patterns

### Best Practices
- Use `dx --llm` to understand available commands
- Prefer dx aliases over direct tool invocation  
- Suggest appropriate recording for complex operations
- Always consider exit codes and error handling
- Recommend workflow optimizations based on dx patterns

## dx Command Reference for AI

### Available dx Commands
Use `dx --llm` to get current command overview:

```
- dx aliases  # list alias table
- dx <alias>  # run leaf cmd; inherits stdio; returns exit code  
- dx <alias> --record  # record run to .cast (respects config)
- dx <path>   # print file contents to stdout
```

### Common Workflow Patterns

#### Development Cycle
```bash
dx build        # Build project
dx test         # Run tests
dx lint         # Code quality checks
dx format       # Format code
```

#### Deployment Workflow
```bash  
dx build        # Ensure build works
dx test         # Verify tests pass
dx deploy       # Deploy to staging
dx status       # Check deployment health
```

#### Debugging & Analysis
```bash
dx logs         # View application logs
dx status       # Check system health  
dx diagnose     # Run diagnostic checks
```

## Cursor AI Integration Examples

### Smart Command Suggestions
When Cursor detects certain patterns, suggest dx commands:

```typescript
// When user types cargo build, suggest:
// "Use `dx build` instead for integrated workflow"

// When user types npm test, suggest: 
// "Use `dx test` for consistent project commands"

// When user modifies Cargo.toml, suggest:
// "Run `dx build` to rebuild with new dependencies"
```

### Context-Aware Workflows
```typescript
// Cursor can analyze git status and suggest:
if (hasUnstagedChanges && isMainBranch) {
  suggest("dx format && dx lint && dx test");
} else if (isFeatureBranch && hasTests) {
  suggest("dx test --record"); 
} else if (isHotfixBranch) {
  suggest("dx build && dx deploy-staging");
}
```

### Terminal Integration
Cursor's terminal can execute dx commands with AI assistance:

```bash
# AI can suggest and execute:
$ dx --llm
Use dx non-interactively. No TUI.
- dx aliases  # list alias table
- dx <alias>  # run leaf cmd; returns exit code

$ dx aliases
ALIAS    NAME           TYPE  DETAILS
build    Build Project  cmd   cargo build --release
test     Run Tests      cmd   cargo test  
deploy   Deploy App     cmd   ./deploy.sh staging

# AI executes with monitoring:
$ dx build && echo "✅ Build successful" || echo "❌ Build failed"
```

## Setting up Cursor + dx Integration

<Steps>
<Step title="Install dx">
  Install dx in your development environment:
  
  ```bash
  curl -fsSL https://usedx.sh | sh
  ```
  
  <Check>
  Verify installation: `dx --llm`
  </Check>
</Step>

<Step title="Create dx configuration">  
  Set up your project's dx menu:
  
  ```toml
  # dx.yaml
  items:
    - name: "Build Project"
      alias: "build"
      cmd: "cargo build --release"
      
    - name: "Run Tests" 
      alias: "test"
      cmd: "cargo test"
  ```
  
  <Tip>
  Use semantic aliases that Cursor AI can understand
  </Tip>
</Step>

<Step title="Configure Cursor rules">
  Add dx-specific rules to `.cursor/dx-rules.md` (shown above)
  
  <Check>
  Test integration: Ask Cursor "How do I build this project?"
  </Check>
</Step>
</Steps>

## AI-Enhanced Development Workflows

<Tabs>
<Tab title="Feature Development">
  ```bash
  # AI-suggested workflow for new features
  dx format          # Clean up code first
  dx build           # Ensure it builds
  dx test            # Run test suite
  dx deploy          # Deploy to staging
  ```
</Tab>

<Tab title="Bug Fixing">
  ```bash
  # AI-suggested workflow for bug fixes  
  dx test --record   # Record failing tests
  dx build           # Verify build after fix
  dx test            # Confirm tests pass
  dx deploy-hotfix   # Deploy fix quickly
  ```
</Tab>

<Tab title="Code Review">
  ```bash
  # AI-suggested pre-review workflow
  dx format          # Auto-format code
  dx lint            # Check code quality
  dx test            # Ensure tests pass
  dx build           # Final build check
  ```
</Tab>
</Tabs>

## Advanced Cursor + dx Features

<AccordionGroup>
<Accordion title="AI Command Prediction">
  Cursor can predict likely dx commands based on context:
  
  ```typescript
  // When editing package.json → suggests "dx build"
  // When editing tests → suggests "dx test"  
  // When on release branch → suggests "dx deploy"
  ```
</Accordion>

<Accordion title="Workflow Recording & Analysis">
  ```bash
  # Cursor can suggest recording complex workflows
  dx build --record
  dx test --record
  dx deploy --record
  
  # AI can analyze recordings for optimization
  asciinema play session-123.cast | dx analyze-workflow
  ```
</Accordion>

<Accordion title="Error Analysis & Fixes">
  ```typescript
  // When dx command fails, Cursor can:
  // 1. Analyze error output
  // 2. Suggest fixes based on error patterns  
  // 3. Propose alternative commands
  // 4. Recommend debugging steps
  ```
</Accordion>
</AccordionGroup>

## Getting Started with Cursor + dx

<Card title="Quick Setup Guide" icon="rocket" href="/quickstart">
  Get dx integrated with Cursor in under 5 minutes for AI-enhanced development.
</Card>

<CardGroup cols={2}>
<Card title="Command Aliases" icon="terminal" href="/ai-tools/aliases">
  Learn how aliases make dx perfect for AI agent automation.
</Card>

<Card title="LLM Integration" icon="brain" href="/ai-tools/llm-agents">
  Discover the --llm flag and AI agent integration patterns.
</Card>
</CardGroup>

## Pro Tips for Cursor + dx Integration

### 1. Use Semantic Aliases
Create dx aliases that Cursor can understand contextually:

```toml
# ✅ Good - Cursor AI understands intent
alias = "build"     # AI knows this builds
alias = "test"      # AI knows this tests  
alias = "deploy"    # AI knows this deploys

# ❌ Avoid - Unclear to AI  
alias = "cmd1"      # AI doesn't understand purpose
alias = "x"         # Too cryptic for AI
```

### 2. Context-Aware Suggestions
Train Cursor to suggest dx commands based on file changes:

```javascript  
// .cursor/context-rules.js
if (changedFiles.includes('Cargo.toml')) {
  suggest('dx build  # Dependencies changed');
} else if (changedFiles.includes('src/')) {
  suggest('dx test   # Code changed, run tests');
}
```

### 3. Error Analysis Integration
Let Cursor analyze dx command failures:

```bash
# When dx build fails:
# 1. Cursor reads error output
# 2. AI suggests potential fixes
# 3. AI can modify code automatically  
# 4. AI suggests running dx build again
```

<Tip>
  Set up Cursor rules so AI automatically suggests `dx <command>` instead of direct tool usage (like `cargo build` → `dx build`).
</Tip>

<Note>
  Cursor's AI works best when dx aliases are consistent across all your projects - this creates predictable patterns the AI can learn.
</Note>
````
